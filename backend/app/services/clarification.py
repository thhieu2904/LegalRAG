#!/usr/bin/env python3
"""
Smart Clarification Service for LegalRAG
========================================

T·∫°o c√¢u h·ªèi clarification th√¥ng minh d·ª±a tr√™n confidence levels:
- High confidence (0.7-0.84): X√°c nh·∫≠n v·ªõi g·ª£i √Ω c·ª• th·ªÉ
- Medium confidence (0.5-0.69): Multiple choices t·ª´ top matches  
- Low confidence (0.0-0.49): Category-based suggestions

Author: LegalRAG Team
"""

from typing import Dict, List, Any, Optional, Tuple
import logging
from dataclasses import dataclass

logger = logging.getLogger(__name__)

@dataclass
class ClarificationLevel:
    """ƒê·ªãnh nghƒ©a c√°c m·ª©c clarification"""
    min_confidence: float
    max_confidence: float
    strategy: str
    message_template: str

class ClarificationService:
    """Service t·∫°o clarification th√¥ng minh d·ª±a tr√™n confidence levels"""
    
    def __init__(self):
        self.clarification_levels = {
            'high_confidence': ClarificationLevel(
                min_confidence=0.80,
                max_confidence=1.00,
                strategy='auto_route',
                message_template="Routing automatically to '{procedure}' (confidence: {confidence:.1%})"
            ),
            'medium_high_confidence': ClarificationLevel(
                min_confidence=0.65,
                max_confidence=0.79,
                strategy='questions_in_document', 
                message_template="T√¥i nghƒ© b·∫°n mu·ªën h·ªèi v·ªÅ '{procedure}'. Ch·ªçn c√¢u h·ªèi c·ª• th·ªÉ ho·∫∑c t·ª± nh·∫≠p:"
            ),
            'medium_confidence': ClarificationLevel(
                min_confidence=0.50,
                max_confidence=0.64,
                strategy='multiple_choices',
                message_template="C√¢u h·ªèi c·ªßa b·∫°n c√≥ th·ªÉ li√™n quan ƒë·∫øn c√°c th·ªß t·ª•c sau. B·∫°n mu·ªën h·ªèi v·ªÅ:"
            ),
            'low_confidence': ClarificationLevel(
                min_confidence=0.00,
                max_confidence=0.49,
                strategy='category_suggestions',
                message_template="T√¥i ch∆∞a hi·ªÉu r√µ √Ω b·∫°n. B·∫°n c√≥ th·ªÉ cho bi·∫øt b·∫°n quan t√¢m ƒë·∫øn lƒ©nh v·ª±c n√†o?"
            )
        }
        
        # Category mappings cho low confidence - UPDATED FOR NEW STRUCTURE
        self.category_suggestions = {
            # Old structure compatibility
            'ho_tich_cap_xa': {
                'title': 'H·ªô t·ªãch c·∫•p x√£',
                'description': 'Khai sinh, k·∫øt h√¥n, khai t·ª≠, thay ƒë·ªïi h·ªô t·ªãch',
                'examples': ['khai sinh con', 'ƒëƒÉng k√Ω k·∫øt h√¥n', 'l√†m l·∫°i gi·∫•y khai sinh']
            },
            'chung_thuc': {
                'title': 'Ch·ª©ng th·ª±c',
                'description': 'Ch·ª©ng th·ª±c h·ª£p ƒë·ªìng, ch·ªØ k√Ω, b·∫£n sao gi·∫•y t·ªù',
                'examples': ['ch·ª©ng th·ª±c h·ª£p ƒë·ªìng mua b√°n', 'ch·ª©ng th·ª±c ch·ªØ k√Ω', 'ch·ª©ng th·ª±c b·∫£n sao']
            },
            'nuoi_con_nuoi': {
                'title': 'Nu√¥i con nu√¥i',
                'description': 'Th·ªß t·ª•c nh·∫≠n con nu√¥i, gi√°m h·ªô',
                'examples': ['nh·∫≠n con nu√¥i', 'th·ªß t·ª•c nu√¥i con nu√¥i', 'gi√°m h·ªô tr·∫ª em']
            },
            # New structure mappings
            'quy_trinh_cap_ho_tich_cap_xa': {
                'title': 'H·ªô t·ªãch c·∫•p x√£',
                'description': 'Khai sinh, k·∫øt h√¥n, khai t·ª≠, thay ƒë·ªïi h·ªô t·ªãch',
                'examples': ['khai sinh con', 'ƒëƒÉng k√Ω k·∫øt h√¥n', 'l√†m l·∫°i gi·∫•y khai sinh']
            },
            'quy_trinh_chung_thuc': {
                'title': 'Ch·ª©ng th·ª±c',
                'description': 'Ch·ª©ng th·ª±c h·ª£p ƒë·ªìng, ch·ªØ k√Ω, b·∫£n sao gi·∫•y t·ªù, di ch√∫c',
                'examples': ['ch·ª©ng th·ª±c h·ª£p ƒë·ªìng mua b√°n', 'ch·ª©ng th·ª±c di ch√∫c', 'ch·ª©ng th·ª±c b·∫£n sao']
            },
            'quy_trinh_nuoi_con_nuoi': {
                'title': 'Nu√¥i con nu√¥i',
                'description': 'Th·ªß t·ª•c nh·∫≠n con nu√¥i, gi√°m h·ªô',
                'examples': ['nh·∫≠n con nu√¥i', 'th·ªß t·ª•c nu√¥i con nu√¥i', 'gi√°m h·ªô tr·∫ª em']
            }
        }
    
    def generate_clarification(
        self, 
        confidence: float,
        routing_result: Dict[str, Any],
        query: str
    ) -> Dict[str, Any]:
        """
        T·∫°o clarification th√¥ng minh d·ª±a tr√™n confidence level
        """
        try:
            # Convert numpy types to Python native types ƒë·ªÉ tr√°nh l·ªói serialization
            confidence = float(confidence) if confidence is not None else 0.0
            
            # X√°c ƒë·ªãnh clarification level
            clarification_level = self._determine_clarification_level(confidence)
            level_config = self.clarification_levels[clarification_level]
            
            logger.info(f"üéØ Generating {clarification_level} clarification for confidence: {confidence:.3f}")
            
            # Generate theo strategy
            if level_config.strategy == 'auto_route':
                return self._generate_auto_route_response(confidence, routing_result, level_config)
            
            elif level_config.strategy == 'questions_in_document':
                return self._generate_questions_in_document_clarification(confidence, routing_result, level_config)
            
            elif level_config.strategy == 'confirm_with_suggestion':
                return self._generate_confirmation_clarification(confidence, routing_result, level_config)
            
            elif level_config.strategy == 'multiple_choices':
                return self._generate_multiple_choice_clarification(confidence, routing_result, level_config)
            
            elif level_config.strategy == 'category_suggestions':
                return self._generate_category_clarification(confidence, routing_result, level_config)
            
            else:
                # Fallback
                return self._generate_fallback_clarification(confidence, routing_result)
                
        except Exception as e:
            logger.error(f"Error generating smart clarification: {e}")
            return self._generate_fallback_clarification(float(confidence) if confidence is not None else 0.0, routing_result)
    
    def _determine_clarification_level(self, confidence: float) -> str:
        """X√°c ƒë·ªãnh clarification level d·ª±a tr√™n confidence - UPDATED WITH 4 LEVELS"""
        # FIXED: Ki·ªÉm tra theo th·ª© t·ª± t·ª´ cao xu·ªëng th·∫•p ƒë·ªÉ tr√°nh overlap
        if confidence >= 0.80:
            return 'high_confidence'
        elif confidence >= 0.65 and confidence < 0.80:
            return 'medium_high_confidence'
        elif confidence >= 0.50 and confidence < 0.65:
            return 'medium_confidence'
        elif confidence >= 0.00 and confidence < 0.50:
            return 'low_confidence'
        
        # Edge cases
        else:
            return 'low_confidence'
    
    def _generate_auto_route_response(
        self, 
        confidence: float, 
        routing_result: Dict[str, Any], 
        level_config: ClarificationLevel
    ) -> Dict[str, Any]:
        """
        HIGH CONFIDENCE (>0.80): Auto route without clarification
        """
        return {
            "type": "auto_route",
            "confidence_level": "high_confidence",
            "confidence": float(confidence),
            "routing_result": routing_result,
            "message": "Routing automatically with high confidence",
            "strategy": level_config.strategy
        }
    
    def _generate_questions_in_document_clarification(
        self, 
        confidence: float, 
        routing_result: Dict[str, Any], 
        level_config: ClarificationLevel
    ) -> Dict[str, Any]:
        """
        MEDIUM-HIGH CONFIDENCE (0.65-0.79): Show questions within best matched document
        """
        source_procedure = routing_result.get('source_procedure', 'th·ªß t·ª•c n√†y')
        target_collection = routing_result.get('target_collection')
        
        # Debug logging
        logger.info(f"üîç MEDIUM-HIGH DEBUG: source_procedure={source_procedure}, target_collection={target_collection}")
        logger.info(f"üîç MEDIUM-HIGH DEBUG: routing_result keys={list(routing_result.keys())}")
        
        # Handle case where source_procedure is None
        if source_procedure is None or source_procedure == 'th·ªß t·ª•c n√†y':
            # Try to get display name from collection mappings
            display_name = routing_result.get('display_name')
            if display_name:
                source_procedure = display_name
            else:
                source_procedure = f"th·ªß t·ª•c trong {target_collection}" if target_collection else "th·ªß t·ª•c n√†y"
        
        # Get similarity info from routing result
        best_match_info = routing_result.get('best_match', {})
        similarity_percent = best_match_info.get('similarity_percent', round(confidence * 100, 1))
        best_question = best_match_info.get('question', '')
        
        # Enhanced message with similarity info
        if best_question:
            message = f"T√¥i nghƒ© b·∫°n mu·ªën h·ªèi v·ªÅ '{source_procedure}'. C√¢u h·ªèi t∆∞∆°ng t·ª± nh·∫•t ({similarity_percent}%): \"{best_question[:60]}...\"\n\nCh·ªçn c√¢u h·ªèi c·ª• th·ªÉ ho·∫∑c t·ª± nh·∫≠p:"
        else:
            message = level_config.message_template.format(
                procedure=source_procedure,
                confidence=confidence
            )
        
        # This will be handled by RAG engine to get questions from the specific document
        options = [
            {
                'id': 'show_questions',
                'title': f"Xem c√¢u h·ªèi v·ªÅ {source_procedure}",
                'description': f"Hi·ªÉn th·ªã c√°c c√¢u h·ªèi th∆∞·ªùng g·∫∑p v·ªÅ {source_procedure}",
                'action': 'show_document_questions',  # New action for medium-high
                'collection': target_collection,
                'procedure': source_procedure,
                'document_title': source_procedure  # Pass procedure as document title
            },
            {
                'id': 'manual',
                'title': "T√¥i mu·ªën m√¥ t·∫£ c√¢u h·ªèi c·ª• th·ªÉ",
                'description': "ƒê·ªÉ t√¥i di·ªÖn ƒë·∫°t l·∫°i c√¢u h·ªèi m·ªôt c√°ch chi ti·∫øt h∆°n",
                'action': 'manual_input',
                'collection': target_collection
            }
        ]
        
        return {
            "type": "clarification_needed",
            "confidence_level": "medium_high_confidence",
            "confidence": float(confidence),
            "clarification": {
                "message": message,
                "options": options,
                "style": "questions_in_document"
            },
            "routing_context": routing_result,
            "strategy": level_config.strategy
        }

    def _generate_confirmation_clarification(
        self, 
        confidence: float, 
        routing_result: Dict[str, Any], 
        level_config: ClarificationLevel
    ) -> Dict[str, Any]:
        """
        HIGH CONFIDENCE (0.7-0.84): X√°c nh·∫≠n v·ªõi g·ª£i √Ω c·ª• th·ªÉ
        """
        source_procedure = routing_result.get('source_procedure', 'th·ªß t·ª•c n√†y')
        best_match = routing_result.get('matched_example', '')
        
        message = level_config.message_template.format(
            procedure=source_procedure,
            confidence=confidence
        )
        
        options = [
            {
                'id': 'yes',
                'title': f"ƒê√∫ng, t√¥i mu·ªën h·ªèi v·ªÅ {source_procedure}",
                'description': f"Ti·∫øn h√†nh t√¨m ki·∫øm th√¥ng tin v·ªÅ {source_procedure}",
                'action': 'proceed_with_collection',  # üîß CHANGE: Unified action name
                'collection': routing_result.get('target_collection'),
                'procedure': source_procedure
            },
            {
                'id': 'similar',
                'title': "T∆∞∆°ng t·ª±, nh∆∞ng kh√¥ng ho√†n to√†n ch√≠nh x√°c",
                'description': f"C√¢u h·ªèi g·ªëc: {best_match[:80]}..." if best_match else "H√£y gi√∫p t√¥i t√¨m th·ªß t·ª•c ph√π h·ª£p h∆°n",
                'action': 'proceed_with_collection',  # üîß CHANGE: Use same action, let collection decide
                'collection': routing_result.get('target_collection')
            },
            {
                'id': 'no',
                'title': "Kh√¥ng, t√¥i mu·ªën h·ªèi v·ªÅ th·ªß t·ª•c kh√°c",
                'description': "H√£y cho t√¥i th√™m l·ª±a ch·ªçn kh√°c",
                'action': 'manual_input',  # üîß CHANGE: Ask for manual input
                'collection': None
            }
        ]
        
        return {
            "type": "clarification_needed",
            "confidence_level": "high_confidence",
            "confidence": float(confidence),
            "clarification": {
                "message": message,
                "options": options,
                "style": "confirmation"
            },
            "routing_context": routing_result,
            "strategy": level_config.strategy
        }
    
    def _generate_multiple_choice_clarification(
        self, 
        confidence: float, 
        routing_result: Dict[str, Any], 
        level_config: ClarificationLevel
    ) -> Dict[str, Any]:
        """
        MEDIUM CONFIDENCE (0.5-0.69): Multiple choices t·ª´ top matches
        """
        # L·∫•y top matches t·ª´ routing result (c·∫ßn implement trong smart_router)
        all_scores = routing_result.get('all_scores', {})
        top_matches = sorted(all_scores.items(), key=lambda x: x[1], reverse=True)[:3]
        
        message = level_config.message_template
        
        options = []
        for i, (collection, score) in enumerate(top_matches, 1):
            collection_display = self.category_suggestions.get(collection, {})
            
            # Convert numpy types to Python native types
            score_float = float(score) if score is not None else 0.0
            
            option = {
                'id': str(i),
                'title': collection_display.get('title', collection),
                'description': collection_display.get('description', ''),
                'confidence': f"{score_float:.1%}",
                'examples': collection_display.get('examples', [])[:2],
                'action': 'proceed_with_collection',
                'collection': collection
            }
            options.append(option)
        
        # Add "none of the above" option
        options.append({
            'id': 'other',
            'title': "Kh√¥ng c√≥ th·ªß t·ª•c n√†o ph√π h·ª£p",
            'description': "T√¥i mu·ªën h·ªèi v·ªÅ th·ªß t·ª•c kh√°c",
            'action': 'manual_input',
            'collection': None
        })
        
        return {
            "type": "clarification_needed",
            "confidence_level": "medium_confidence",
            "confidence": float(confidence),
            "clarification": {
                "message": message,
                "options": options,
                "style": "multiple_choice"
            },
            "routing_context": routing_result,
            "strategy": level_config.strategy
        }
    
    def _generate_category_clarification(
        self, 
        confidence: float, 
        routing_result: Dict[str, Any], 
        level_config: ClarificationLevel
    ) -> Dict[str, Any]:
        """
        LOW CONFIDENCE (0.0-0.49): Category-based suggestions
        """
        message = level_config.message_template
        
        options = []
        for i, (collection_id, category_info) in enumerate(self.category_suggestions.items(), 1):
            option = {
                'id': str(i),
                'title': category_info['title'],
                'description': category_info['description'],
                'examples': category_info['examples'],
                'action': 'proceed_with_collection',  # üîß CHANGE: Match handler expectation
                'collection': collection_id
            }
            options.append(option)
        
        # Add manual input option
        options.append({
            'id': 'manual',
            'title': "T√¥i mu·ªën m√¥ t·∫£ r√µ h∆°n",
            'description': "ƒê·ªÉ t√¥i di·ªÖn ƒë·∫°t l·∫°i c√¢u h·ªèi m·ªôt c√°ch chi ti·∫øt h∆°n",
            'action': 'manual_input',
            'collection': None
        })
        
        return {
            "type": "clarification_needed",
            "confidence_level": "low_confidence",
            "confidence": float(confidence),
            "clarification": {
                "message": message,
                "options": options,
                "style": "category_based",
                "additional_help": "B·∫°n c√≥ th·ªÉ m√¥ t·∫£ c·ª• th·ªÉ h∆°n v·ªÅ t√¨nh hu·ªëng ho·∫∑c gi·∫•y t·ªù b·∫°n c·∫ßn l√†m"
            },
            "routing_context": routing_result,
            "strategy": level_config.strategy
        }
    
    def _generate_fallback_clarification(
        self, 
        confidence: float, 
        routing_result: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Fallback clarification khi c√≥ l·ªói"""
        return {
            "type": "clarification_needed",
            "confidence_level": "fallback",
            "confidence": float(confidence),
            "clarification": {
                "message": "Xin l·ªói, t√¥i c·∫ßn th√™m th√¥ng tin ƒë·ªÉ hi·ªÉu r√µ c√¢u h·ªèi c·ªßa b·∫°n.",
                "options": [
                    {
                        'id': 'retry',
                        'title': "H√£y di·ªÖn ƒë·∫°t l·∫°i c√¢u h·ªèi",
                        'description': "T√¥i s·∫Ω c·ªë g·∫Øng hi·ªÉu r√µ h∆°n",
                        'action': 'manual_input'
                    }
                ],
                "style": "fallback"
            },
            "routing_context": routing_result,
            "strategy": "fallback"
        }
    
    def get_related_procedures(self, collection: str, procedure: str, limit: int = 3) -> List[Dict[str, Any]]:
        """
        L·∫•y c√°c th·ªß t·ª•c li√™n quan trong c√πng collection
        (C√≥ th·ªÉ integrate v·ªõi smart_router ƒë·ªÉ l·∫•y similar procedures)
        """
        # Placeholder - s·∫Ω integrate v·ªõi smart_router
        return []
