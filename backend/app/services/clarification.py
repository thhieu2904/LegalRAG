#!/usr/bin/env python3
"""
Smart Clarification Service for LegalRAG
========================================

5-Layer Clarification System:
- High confidence (‚â•0.80): Auto route - no clarification needed
- Medium-High confidence (0.65-0.79): Confirm with best questions
- Medium confidence (0.50-0.64): Multiple choice options
- Low confidence (0.30-0.49): Category-based suggestions
- Insufficient context (<0.30): Context gathering

Author: LegalRAG Team
"""

from typing import Dict, List, Any, Optional, Tuple
import logging
from dataclasses import dataclass

logger = logging.getLogger(__name__)

@dataclass
class ClarificationLevel:
    """ƒê·ªãnh nghƒ©a c√°c m·ª©c clarification"""
    min_confidence: float
    max_confidence: float
    strategy: str
    message_template: str

class ClarificationService:
    """Service t·∫°o clarification th√¥ng minh d·ª±a tr√™n confidence levels"""
    
    def __init__(self):
        self.clarification_levels = {
            'high_confidence': ClarificationLevel(
                min_confidence=0.80,
                max_confidence=1.00,
                strategy='auto_route',
                message_template="Routing automatically with high confidence (confidence: {confidence:.1%})"
            ),
            'medium_high_confidence': ClarificationLevel(
                min_confidence=0.65,
                max_confidence=0.79,
                strategy='confirm_with_best_questions', 
                message_template="T√¥i nghƒ© b·∫°n mu·ªën h·ªèi v·ªÅ '{procedure}' (ƒë·ªô tin c·∫≠y: {confidence:.1%}). ƒê√∫ng kh√¥ng?"
            ),
            'medium_confidence': ClarificationLevel(
                min_confidence=0.50,
                max_confidence=0.64,
                strategy='multiple_choices',
                message_template="C√¢u h·ªèi c·ªßa b·∫°n c√≥ th·ªÉ li√™n quan ƒë·∫øn c√°c th·ªß t·ª•c sau. B·∫°n mu·ªën h·ªèi v·ªÅ:"
            ),
            'low_confidence': ClarificationLevel(
                min_confidence=0.30,
                max_confidence=0.49,
                strategy='category_suggestions',
                message_template="T√¥i ch∆∞a hi·ªÉu r√µ √Ω b·∫°n. B·∫°n c√≥ th·ªÉ cho bi·∫øt b·∫°n quan t√¢m ƒë·∫øn lƒ©nh v·ª±c n√†o?"
            ),
            'insufficient_context': ClarificationLevel(
                min_confidence=0.00,
                max_confidence=0.29,
                strategy='context_gathering',
                message_template="T√¥i c·∫ßn th√™m th√¥ng tin ƒë·ªÉ hi·ªÉu r√µ c√¢u h·ªèi c·ªßa b·∫°n. B·∫°n c√≥ th·ªÉ:"
            )
        }
        
        # Category mappings cho low confidence - UPDATED FOR NEW STRUCTURE
        self.category_suggestions = {
            # Old structure compatibility
            'ho_tich_cap_xa': {
                'title': 'H·ªô t·ªãch c·∫•p x√£',
                'description': 'Khai sinh, k·∫øt h√¥n, khai t·ª≠, thay ƒë·ªïi h·ªô t·ªãch',
                'examples': ['khai sinh con', 'ƒëƒÉng k√Ω k·∫øt h√¥n', 'l√†m l·∫°i gi·∫•y khai sinh']
            },
            'chung_thuc': {
                'title': 'Ch·ª©ng th·ª±c',
                'description': 'Ch·ª©ng th·ª±c h·ª£p ƒë·ªìng, ch·ªØ k√Ω, b·∫£n sao gi·∫•y t·ªù',
                'examples': ['ch·ª©ng th·ª±c h·ª£p ƒë·ªìng mua b√°n', 'ch·ª©ng th·ª±c ch·ªØ k√Ω', 'ch·ª©ng th·ª±c b·∫£n sao']
            },
            'nuoi_con_nuoi': {
                'title': 'Nu√¥i con nu√¥i',
                'description': 'Th·ªß t·ª•c nh·∫≠n con nu√¥i, gi√°m h·ªô',
                'examples': ['nh·∫≠n con nu√¥i', 'th·ªß t·ª•c nu√¥i con nu√¥i', 'gi√°m h·ªô tr·∫ª em']
            },
            # New structure mappings
            'quy_trinh_cap_ho_tich_cap_xa': {
                'title': 'H·ªô t·ªãch c·∫•p x√£',
                'description': 'Khai sinh, k·∫øt h√¥n, khai t·ª≠, thay ƒë·ªïi h·ªô t·ªãch',
                'examples': ['khai sinh con', 'ƒëƒÉng k√Ω k·∫øt h√¥n', 'l√†m l·∫°i gi·∫•y khai sinh']
            },
            'quy_trinh_chung_thuc': {
                'title': 'Ch·ª©ng th·ª±c',
                'description': 'Ch·ª©ng th·ª±c h·ª£p ƒë·ªìng, ch·ªØ k√Ω, b·∫£n sao gi·∫•y t·ªù, di ch√∫c',
                'examples': ['ch·ª©ng th·ª±c h·ª£p ƒë·ªìng mua b√°n', 'ch·ª©ng th·ª±c di ch√∫c', 'ch·ª©ng th·ª±c b·∫£n sao']
            },
            'quy_trinh_nuoi_con_nuoi': {
                'title': 'Nu√¥i con nu√¥i',
                'description': 'Th·ªß t·ª•c nh·∫≠n con nu√¥i, gi√°m h·ªô',
                'examples': ['nh·∫≠n con nu√¥i', 'th·ªß t·ª•c nu√¥i con nu√¥i', 'gi√°m h·ªô tr·∫ª em']
            }
        }
    
    def generate_clarification(
        self, 
        confidence: float,
        routing_result: Dict[str, Any],
        query: str
    ) -> Dict[str, Any]:
        """
        T·∫°o clarification th√¥ng minh d·ª±a tr√™n confidence level
        """
        try:
            # Convert numpy types to Python native types ƒë·ªÉ tr√°nh l·ªói serialization
            confidence = float(confidence) if confidence is not None else 0.0
            
            # X√°c ƒë·ªãnh clarification level
            clarification_level = self._determine_clarification_level(confidence)
            level_config = self.clarification_levels[clarification_level]
            
            logger.info(f"üéØ Generating {clarification_level} clarification for confidence: {confidence:.3f}")
            
            # Generate theo strategy - 5-LAYER SYSTEM
            if level_config.strategy == 'auto_route':
                return self._generate_auto_route_response(confidence, routing_result, level_config)
            
            elif level_config.strategy == 'confirm_with_best_questions':
                return self._generate_confirmation_clarification(confidence, routing_result, level_config)
            
            elif level_config.strategy == 'multiple_choices':
                return self._generate_multiple_choice_clarification(confidence, routing_result, level_config)
            
            elif level_config.strategy == 'category_suggestions':
                return self._generate_category_clarification(confidence, routing_result, level_config)
            
            elif level_config.strategy == 'context_gathering':
                return self._generate_context_gathering_clarification(confidence, routing_result, level_config)
            
            else:
                # Fallback
                return self._generate_fallback_clarification(confidence, routing_result)
                
        except Exception as e:
            logger.error(f"Error generating smart clarification: {e}")
            return self._generate_fallback_clarification(float(confidence) if confidence is not None else 0.0, routing_result)
    
    def _determine_clarification_level(self, confidence: float) -> str:
        """X√°c ƒë·ªãnh clarification level d·ª±a tr√™n confidence - 5-LAYER SYSTEM"""
        # Ki·ªÉm tra theo th·ª© t·ª± t·ª´ cao xu·ªëng th·∫•p ƒë·ªÉ tr√°nh overlap
        if confidence >= 0.80:
            return 'high_confidence'
        elif confidence >= 0.65 and confidence < 0.80:
            return 'medium_high_confidence'
        elif confidence >= 0.50 and confidence < 0.65:
            return 'medium_confidence'
        elif confidence >= 0.30 and confidence < 0.50:
            return 'low_confidence'
        elif confidence >= 0.00 and confidence < 0.30:
            return 'insufficient_context'
        else:
            # Edge case - default to insufficient context
            return 'insufficient_context'
    
    def _generate_auto_route_response(
        self, 
        confidence: float, 
        routing_result: Dict[str, Any], 
        level_config: ClarificationLevel
    ) -> Dict[str, Any]:
        """
        HIGH CONFIDENCE (‚â•0.80): Auto route without clarification
        """
        return {
            "type": "auto_route",
            "confidence_level": "high_confidence",
            "confidence": float(confidence),
            "target_collection": routing_result.get('target_collection'),
            "message": level_config.message_template.format(confidence=confidence),
            "routing_context": routing_result,
            "strategy": level_config.strategy
        }
    
    def _generate_context_gathering_clarification(
        self, 
        confidence: float, 
        routing_result: Dict[str, Any], 
        level_config: ClarificationLevel
    ) -> Dict[str, Any]:
        """
        INSUFFICIENT CONTEXT (0.00-0.29): Thu th·∫≠p th√™m context
        """
        message = level_config.message_template
        
        options = [
            {
                'id': 'provide_more_details',
                'title': "M√¥ t·∫£ chi ti·∫øt h∆°n v·ªÅ t√¨nh hu·ªëng",
                'description': "V√≠ d·ª•: B·∫°n ƒëang l√†m th·ªß t·ª•c g√¨? C·∫ßn gi·∫•y t·ªù g√¨?",
                'action': 'request_more_context',
                'context_type': 'situation_description'
            },
            {
                'id': 'select_document_type',
                'title': "Ch·ªçn lo·∫°i gi·∫•y t·ªù b·∫°n c·∫ßn",
                'description': "Gi·∫•y khai sinh, ch·ª©ng minh nh√¢n d√¢n, s·ªï h·ªô kh·∫©u...",
                'action': 'request_document_type',
                'context_type': 'document_type'
            },
            {
                'id': 'select_urgency',
                'title': "M·ª©c ƒë·ªô kh·∫©n c·∫•p",
                'description': "C·∫ßn g·∫•p trong ng√†y, tu·∫ßn n√†y, hay kh√¥ng g·∫•p?",
                'action': 'request_urgency',
                'context_type': 'urgency_level'
            },
            {
                'id': 'manual_description',
                'title': "T√¥i mu·ªën m√¥ t·∫£ chi ti·∫øt",
                'description': "H√£y cho t√¥i nh·∫≠p c√¢u h·ªèi c·ª• th·ªÉ h∆°n",
                'action': 'manual_input',
                'context_type': 'detailed_description'
            }
        ]
        
        return {
            "type": "context_gathering_needed",
            "confidence_level": "insufficient_context",
            "confidence": float(confidence),
            "clarification": {
                "message": message,
                "options": options,
                "style": "context_gathering",
                "requires_user_input": True,
                "additional_help": "B·∫°n c√≥ th·ªÉ m√¥ t·∫£ c·ª• th·ªÉ h∆°n v·ªÅ t√¨nh hu·ªëng ho·∫∑c gi·∫•y t·ªù b·∫°n c·∫ßn l√†m"
            },
            "routing_context": routing_result,
            "strategy": level_config.strategy
        }

    def _generate_confirmation_clarification(
        self, 
        confidence: float, 
        routing_result: Dict[str, Any], 
        level_config: ClarificationLevel
    ) -> Dict[str, Any]:
        """
        MEDIUM-HIGH CONFIDENCE (0.65-0.79): X√°c nh·∫≠n v·ªõi c√¢u h·ªèi g·∫ßn nh·∫•t
        """
        # Fix data mapping - s·ª≠ d·ª•ng structure m·ªõi t·ª´ router
        best_match = routing_result.get('best_match', {})
        source_procedure = best_match.get('question', 'th·ªß t·ª•c n√†y')
        best_question = best_match.get('question', '')
        target_collection = routing_result.get('target_collection')
        
        # N·∫øu kh√¥ng c√≥ best_match, th·ª≠ fallback
        if not source_procedure or source_procedure == 'th·ªß t·ª•c n√†y':
            # Try to get collection display name
            collection_display = self.category_suggestions.get(target_collection, {})
            source_procedure = collection_display.get('title', target_collection or 'th·ªß t·ª•c n√†y')
        
        message = level_config.message_template.format(
            procedure=source_procedure,
            confidence=confidence
        )
        
        # MEDIUM-HIGH: Hi·ªÉn th·ªã c√¢u h·ªèi trong document ƒë·ªÉ ch·ªçn
        # L·∫•y document t·ª´ best_match 
        target_document = best_match.get('document', '')
        
        options = [
            {
                'id': 'yes',
                'title': f"ƒê√∫ng, t√¥i mu·ªën h·ªèi v·ªÅ {source_procedure}",
                'description': f"Hi·ªÉn th·ªã c√¢u h·ªèi v·ªÅ {source_procedure}",
                'action': 'show_document_questions', 
                'collection': target_collection,
                'document': target_document,
                'procedure': source_procedure
            },
            {
                'id': 'similar',
                'title': "T∆∞∆°ng t·ª±, nh∆∞ng kh√¥ng ho√†n to√†n ch√≠nh x√°c",
                'description': f"C√¢u h·ªèi g·ªëc: {best_question[:80]}..." if best_question else "H√£y gi√∫p t√¥i t√¨m th·ªß t·ª•c ph√π h·ª£p h∆°n",
                'action': 'show_document_questions',
                'collection': target_collection,
                'document': target_document,
                'procedure': source_procedure
            },
            {
                'id': 'no',
                'title': "Kh√¥ng, t√¥i mu·ªën h·ªèi v·ªÅ th·ªß t·ª•c kh√°c",
                'description': "H√£y cho t√¥i th√™m l·ª±a ch·ªçn kh√°c",
                'action': 'show_categories',
                'collection': None
            }
        ]
        
        return {
            "type": "clarification_needed",
            "confidence_level": "medium_high_confidence",
            "confidence": float(confidence),
            "clarification": {
                "message": message,
                "options": options,
                "style": "confirmation"
            },
            "routing_context": routing_result,
            "strategy": level_config.strategy
        }
    
    def _generate_multiple_choice_clarification(
        self, 
        confidence: float, 
        routing_result: Dict[str, Any], 
        level_config: ClarificationLevel
    ) -> Dict[str, Any]:
        """
        MEDIUM CONFIDENCE (0.5-0.69): Multiple choices t·ª´ top matches
        """
        # L·∫•y top matches t·ª´ routing result (c·∫ßn implement trong smart_router)
        all_scores = routing_result.get('all_scores', {})
        top_matches = sorted(all_scores.items(), key=lambda x: x[1], reverse=True)[:3]
        
        message = level_config.message_template
        
        options = []
        for i, (collection, score) in enumerate(top_matches, 1):
            collection_display = self.category_suggestions.get(collection, {})
            
            # Convert numpy types to Python native types
            score_float = float(score) if score is not None else 0.0
            
            option = {
                'id': str(i),
                'title': collection_display.get('title', collection),
                'description': collection_display.get('description', ''),
                'confidence': f"{score_float:.1%}",
                'examples': collection_display.get('examples', [])[:2],
                'action': 'proceed_with_collection',
                'collection': collection
            }
            options.append(option)
        
        # Add "none of the above" option
        options.append({
            'id': 'other',
            'title': "Kh√¥ng c√≥ th·ªß t·ª•c n√†o ph√π h·ª£p",
            'description': "T√¥i mu·ªën h·ªèi v·ªÅ th·ªß t·ª•c kh√°c",
            'action': 'manual_input',
            'collection': None
        })
        
        return {
            "type": "clarification_needed",
            "confidence_level": "medium_confidence",
            "confidence": float(confidence),
            "clarification": {
                "message": message,
                "options": options,
                "style": "multiple_choice"
            },
            "routing_context": routing_result,
            "strategy": level_config.strategy
        }
    
    def _generate_category_clarification(
        self, 
        confidence: float, 
        routing_result: Dict[str, Any], 
        level_config: ClarificationLevel
    ) -> Dict[str, Any]:
        """
        LOW CONFIDENCE (0.30-0.49): Category-based suggestions
        """
        message = level_config.message_template
        
        options = []
        # Ch·ªâ hi·ªÉn th·ªã 3 collections ch√≠nh (b·ªè qua duplicates)
        main_collections = {
            'quy_trinh_cap_ho_tich_cap_xa': {
                'title': 'H·ªô t·ªãch c·∫•p x√£',
                'description': 'Khai sinh, k·∫øt h√¥n, khai t·ª≠, thay ƒë·ªïi h·ªô t·ªãch',
                'examples': ['khai sinh con', 'ƒëƒÉng k√Ω k·∫øt h√¥n', 'l√†m l·∫°i gi·∫•y khai sinh']
            },
            'quy_trinh_chung_thuc': {
                'title': 'Ch·ª©ng th·ª±c',
                'description': 'Ch·ª©ng th·ª±c h·ª£p ƒë·ªìng, ch·ªØ k√Ω, b·∫£n sao gi·∫•y t·ªù, di ch√∫c',
                'examples': ['ch·ª©ng th·ª±c h·ª£p ƒë·ªìng mua b√°n', 'ch·ª©ng th·ª±c di ch√∫c', 'ch·ª©ng th·ª±c b·∫£n sao']
            },
            'quy_trinh_nuoi_con_nuoi': {
                'title': 'Nu√¥i con nu√¥i',
                'description': 'Th·ªß t·ª•c nh·∫≠n con nu√¥i, gi√°m h·ªô',
                'examples': ['nh·∫≠n con nu√¥i', 'th·ªß t·ª•c nu√¥i con nu√¥i', 'gi√°m h·ªô tr·∫ª em']
            }
        }
        
        for i, (collection_id, category_info) in enumerate(main_collections.items(), 1):
            option = {
                'id': str(i),
                'title': category_info['title'],
                'description': category_info['description'],
                'examples': category_info['examples'],
                'action': 'proceed_with_collection',
                'collection': collection_id
            }
            options.append(option)
        
        # Add manual input option
        options.append({
            'id': 'manual',
            'title': "T√¥i mu·ªën m√¥ t·∫£ r√µ h∆°n",
            'description': "ƒê·ªÉ t√¥i di·ªÖn ƒë·∫°t l·∫°i c√¢u h·ªèi m·ªôt c√°ch chi ti·∫øt h∆°n",
            'action': 'manual_input',
            'collection': None
        })
        
        return {
            "type": "clarification_needed",
            "confidence_level": "low_confidence",
            "confidence": float(confidence),
            "clarification": {
                "message": message,
                "options": options,
                "style": "category_based",
                "additional_help": "B·∫°n c√≥ th·ªÉ m√¥ t·∫£ c·ª• th·ªÉ h∆°n v·ªÅ t√¨nh hu·ªëng ho·∫∑c gi·∫•y t·ªù b·∫°n c·∫ßn l√†m"
            },
            "routing_context": routing_result,
            "strategy": level_config.strategy
        }
    
    def _generate_fallback_clarification(
        self, 
        confidence: float, 
        routing_result: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Fallback clarification khi c√≥ l·ªói"""
        return {
            "type": "clarification_needed",
            "confidence_level": "fallback",
            "confidence": float(confidence),
            "clarification": {
                "message": "Xin l·ªói, t√¥i c·∫ßn th√™m th√¥ng tin ƒë·ªÉ hi·ªÉu r√µ c√¢u h·ªèi c·ªßa b·∫°n.",
                "options": [
                    {
                        'id': 'retry',
                        'title': "H√£y di·ªÖn ƒë·∫°t l·∫°i c√¢u h·ªèi",
                        'description': "T√¥i s·∫Ω c·ªë g·∫Øng hi·ªÉu r√µ h∆°n",
                        'action': 'manual_input'
                    }
                ],
                "style": "fallback"
            },
            "routing_context": routing_result,
            "strategy": "fallback"
        }
    
    def get_related_procedures(self, collection: str, procedure: str, limit: int = 3) -> List[Dict[str, Any]]:
        """
        L·∫•y c√°c th·ªß t·ª•c li√™n quan trong c√πng collection
        (C√≥ th·ªÉ integrate v·ªõi smart_router ƒë·ªÉ l·∫•y similar procedures)
        """
        # Placeholder - s·∫Ω integrate v·ªõi smart_router
        return []
